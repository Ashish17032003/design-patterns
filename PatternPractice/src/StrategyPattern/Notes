ğŸ“Œ Why is Factory Like This?
Factory Centralizes Object Creation
You donâ€™t directly instantiate objects (new Bus(), new Cab()), instead, the factory does it.
This hides the logic of object creation from the client.
Factory Doesn't Allow Changing Behavior at Runtime
Once TransportationFactory.getTransportation("BUS") returns a Bus object, you canâ€™t change it to a Cab or Bicycle.
Factory is Useful When:
You need to create objects based on some condition.
You donâ€™t want clients to know the exact class names.


ğŸ“Œ Why is Strategy Like This?
Strategy Allows Changing Behavior at Runtime
You can set a different strategy dynamically (context.setStrategy(new Cab());).
This means you donâ€™t need to create a new object every time you want to change behavior.
Strategy Focuses on Behavior, Not Creation
The client already has the objects (new Bus(), new Cab()) and just swaps them as needed.
Strategy is Useful When:
You need to switch behaviors dynamically.
You donâ€™t want multiple object creations (just reuse different strategies).
ğŸ›  When to Use What?

Use Case	Factory Pattern ğŸ­	Strategy Pattern ğŸ­
You need a centralized place for object creation	âœ… Yes	âŒ No
You want to encapsulate behavior changes	        âŒ No	âœ… Yes
Objectâ€™s behavior should be fixed once created	    âœ… Yes	âŒ No
Behavior should be dynamic & changeable at runtime	âŒ No	âœ… Yes
Avoiding new keyword in client code	                âœ… Yes	âŒ No
Reusing the same objects with different behaviors	âŒ No	âœ… Yes

If you need to create different objects based on some condition â†’ use Factory
If you need to change the object's behavior at runtime â†’ use Strategy
ğŸ”¥ Factory is about WHAT object to create.
ğŸ­ Strategy is about HOW an object should behave.

